## 混淆加密

### 业务场景

将用户`id`混淆为8位以内的数字码`code`，并且可以通过`code`还原对应的`id`，其中`id`为从1开始递增的正整数。

### 实现思路

我们可以选择混淆加密的方式来实现这一功能。

其中，我选择公式`code = (id * a + b) mod c`作为我的混淆函数，由于`code`为8位以内的数字码，所以`c`应选择8位以内最大的素数`99999989`，`a`和`b`可以任意自定义。

### 数学证明



### 实验

由于我们的`c`选择了`99999989`，因此为保证唯一性，我们的id最大为99999989，以做到$\{id\}$域和$\{code\}$域中的元素一一对应。

```go
package experiment

import "testing"

const (
	a int64 = 9967
	b int64 = 9973
	c int64 = 99999989
)

func IdHash(id int) int64 {
	return (a*int64(id) + b) % c
}

func TestIdHash(t *testing.T) {
	codeSet := map[int64]int{}
	for id := 1; id < int(c); id++ {
		code := idHash(id)
		if old_id, ok := codeSet[code]; !ok {
			codeSet[code] = id
		} else {
			t.Fatalf("old_id: %v, new_id: %v", old_id, id)
		}
	}
}

```

### 参考

[为什么要用素数作为模](https://flat2010.github.io/2018/04/19/%E6%A8%A1%E8%BF%90%E7%AE%97%E4%B8%AD%E4%B8%BA%E4%BD%95%E8%A6%81%E7%94%A8%E7%B4%A0%E6%95%B0%E4%BD%9C%E4%B8%BA%E6%A8%A1/)